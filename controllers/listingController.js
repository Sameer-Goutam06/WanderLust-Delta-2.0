const wrapAsync = require('../utilities/Errors/wrapAsync.js');
const ExpressError = require('../utilities/Errors/ExpressError.js');
// Require model created in models folder
const Listing = require('../models/listing.js');
const Category=require("../models/category.js");


const multer = require('multer');
const { CloudinaryStorage } = require('multer-storage-cloudinary');
const cloudinary = require('cloudinary').v2;

module.exports.getListings=async (req, res) => {
        // Fetch all categories
        const categories = await Category.find();
    
        // Fetch all listings by default
        let listings = await Listing.find();
        
        // Render the view with all listings and categories
        res.render('listings/index', {
            l: listings,
            categories: categories,
            selectedCategories: [], // No filters applied
            applyTaxation: false,
            isApplyFiltersPage: false
        });
}

module.exports.getFilteredListings=async (req, res) => {
    const selectedCategories = req.body.categories || []; // `categories` will be an array of selected category IDs
    const applyTaxation = req.body.taxation === 'true'; // Convert the checkbox value to boolean
    // Redirect to /listings if no categories are selected and taxation is not checked
    if (selectedCategories.length === 0 && !applyTaxation) {
        return res.redirect('/listings');
    }
    // Build query based on selected filters
    const query = selectedCategories.length > 0 ? { categories: { $in: selectedCategories } } : {};
    // Find listings that match the selected filters
    let listings = await Listing.find(query);
    // Apply taxation if checkbox is checked
    if (applyTaxation) {
        listings = listings.map(listing => {
            return {
                ...listing._doc, // Preserve original listing data
                price: (listing.price * (res.locals.taxationRate || 1)).toFixed(2) // Apply taxation rate to price
            };
        });
    }
    // Fetch all categories for the filter form
    const categories = await Category.find();
    // Render the filtered view
    res.render('listings/index', {
        l: listings,
        categories: categories,
        selectedCategories: selectedCategories,
        applyTaxation: applyTaxation,
        isApplyFiltersPage: true // Indicate that we are on the Apply Filters page
    });
}

module.exports.getSearchedListings=async (req, res) => {
    const searchQuery = req.query.query || '';
    const regex = new RegExp(searchQuery, 'i');
    const listings = await Listing.find({
        $or: [
            { title: new RegExp(searchQuery, 'i') },
            { country: new RegExp(searchQuery, 'i') },
            { location: new RegExp(searchQuery, 'i') }
        ]
    });
    res.render('listings/search', {
        l: listings,
        searchQuery: searchQuery
    });
}

module.exports.getNewListings=async(req, res) => {
    console.log(res.locals.currentUser.username);
    if(((res.locals.currentUser.username)!=="Admin"))
    {
        throw new ExpressError(404,"Only the developer of this website is authorized to create a new listing");
    }
    const categories = await Category.find({});
    res.render('listings/new', { categories });
}

module.exports.addImageToListing = async(req, res, next) => {
    if (!req.file) {
        throw new ExpressError(400,"Image is required");
    }
    const url = req.file.path; // URL generated by Cloudinary
    const filename = req.file.filename; // Filename given by Cloudinary
    req.body.listing.image = { filename,url };
    next();
};

module.exports.postNewListings=async(req, res) => {
    const newListing = new Listing(req.body.listing);
    if(((res.locals.currentUser.username)!=="Admin"))
    {
        throw new ExpressError(404,"Only the developer of this website is authorized to create a new listing");
    }
    newListing.owner=req.user._id;
    await newListing.save();
    console.log('Inserted successfully');
    console.log(newListing);
    req.flash("success","New Stay Created");
    res.redirect('/listings');
}

module.exports.getListingsById=async (req, res) => {
    const { id } = req.params;
    const result = await Listing.findById(id).populate({path:"reviews",populate:{path:"author"}});
    if (!result) {
        req.flash("error","Location Unavailable");
        return res.redirect("/listings");
    }
    if (result.reviews.length > 0) {
        const totalRating = result.reviews.reduce((sum, review) => sum + review.rating, 0);
        result.averageRating = (totalRating / result.reviews.length).toFixed(2);
    } else {
        result.averageRating = 0;
    }
    res.render('listings/show', { result });
}

module.exports.getEditListings=async (req, res) => {
    const { id } = req.params;
    const result = await Listing.findById(id);
    const categories = await Category.find({});
    res.render('listings/edit', { result, categories });
}

module.exports.checkAndUpdateImage=(req, res, next)=> {
    console.log(req.body);
    if (typeof req.file!=="undefined") {
        upload.single("listing[image]")(req, res, (err) => {
            if (err) {
                return next(err);
            }
            addImageToListing(req, res, next);
        });
    } 
    else {
        next();
    }
}

module.exports.putEditListings=async (req, res) => {
    const { id } = req.params;
    const updationData = req.body.listing;
    const updatedListing = await Listing.findByIdAndUpdate(id, updationData, { new: true });
    console.log(updatedListing?'Updation successful':"Updation unsuccessful");
    req.flash("success","Updation for Stay is successful");
    return res.redirect(`/listings/${id}`);
}

module.exports.deleteListings=async (req, res) => {
    const { id } = req.params;
    await Listing.findByIdAndDelete(id);
    console.log('Deletion successful');
    req.flash("success","Deletion of Stay is successful");
    res.redirect('/listings');
    //if we are deleting a particular destination then we must say that the reviews given for the destination are to be deleted
    //so the deletion process of reviews will be done in /models/listing.js
    //we use mongoDB techniques to delete all the reviews related to a stay
}